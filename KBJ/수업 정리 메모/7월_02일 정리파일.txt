1. JVM이 main을 부르고 public해서 다른 패키지에서도 부를 수 있었고 static해서 메모리에 올라가 있는 main을 사용할 수 있었다.
static // 메모리에 미리 오려 놓음

변수와 차이=> 변수는 new 할때 메모리에 올라간다.(메모리에 올라갈때)
static 영역에서 static이 아닌 것을 사용 하면 안됨=> 생성시점이 다름 
new 인스턴스화
즉 메모리 공간에 올라와 있는 함수에서 메모리에 없는 함수를 부를 수 없음

※static=> 하나만 만들어 져서 여러곳에서 같이 쓰임


추상클래스 => new 가 안된다.
추상클래스가 부모일때 인스턴스를 자식으로 가질 시에 그것을 사용하기 위해서 추상클래스를 만들기도 한다.
많은 개념들을 일반화 시켜놓은 클래스

자동차, 음식, 포유류 => 추상적인 친구들(일반화 시켜 놓은 것, 인스턴스가 될 수 없는 것)
트럭 =>구체적인 친구들
공작 , 참새, 비둘기 => 새 (일반화)
자동차 => 버스, 스포츠카, 포크레인(확장,상속)

추상클래스의 장점
=> 상속되는 클래스는 추상클래스의 메서드를 구현해야함(강제성도/ 갖음)

자바 컨벤션
자바에서 언더바(_) => 상수에서만(대문자만 쓰기위해)

상속관계에서 부모와 자식에 같은 메서드가 있으면 무조건 자식 것을 쓴다.(overriding)

부모 타입으로 자식을 가리킬 수 있다.
ex) 자동차  1c = new 버스(); => 똑같은 메서드가 있을때 기본적으로 자식의 메서드를 쓴다.
			=> 필드는 자신의 타입의 변수를 쓴다.
클래스 생성시
필드 => 메모리에 저장됨
메서드 => 메서드 영역을 따로 가지고 있다.



다형성 어떤 인스턴스가 오느냐에 따라서 같은 메서드가 달라지는 것
=> WAS는 매번 똑같은 것을 부르는데 인스턴스(내용)만 바뀌어서 다른 화면이 나타나는 것!
자동차 c1 = new 스포츠카();
자동차 c2 = new 버스();
자동차 c3 = new 포크레인();
c1.달리다();
c2.달리다();
c3.달리다();
=> 기본적으로 자동차에있는 메서드, 필드만 사용 가능 하지만 자식클래스에 있는 것들이 필요하면 형 변환을 해야한다.
=> 조상이 자손을 가지고 있을 수 있다. 하지만 조상이 가지고 있는 메서드만 사용할 수 있다.


인터페이스
 껍데기?=> 구현체를 가지지 못한다.
=> 리모컨을 대부분 한번에 사용할 수 있는 경우랑 비슷하게 기능을 통일시켜 사용자가 사용하기(짐작하기) 편하도록 하는 것 (기능을 통일 시키는 것)
인터페이스, 구현체로 나뉘고 인터페이스끼리 상속도 됨,
인터페이스는 모든 메서드는 선언만 되어있고 구현은 되어있지 않다.
인터페이스도 추상클래스와 마찬가지로 인스턴스가 될 수 없다.
기존의 인터페이스에 메서드를 추가 하고 싶으면 default메서드를 구현 해놓으면 된다(원래는 안되지만 버전이 올라가면서 된다.)





============================================
※객체들의 집합이 프로그램이 되며, 객체는 데이터와 그 데이터를 처리할 수 있는 메서드를 가지게 된다.

캡슐화=> 클래스 안에 메서드, 필드를 넣어 놓는거
정보 은닉 => private...
상속  =>...
다형성 => 새 - 짹짹, 꽥꽥, 구구


※하나의 메서드가 너무 크면 안됨.. 기능을 나눌 수 있으면 나누는게 좋다.


객체의 정의
 객체는 효율적인 정보관리를 위해 사람
클래스 --> 인스턴스(인스턴트 화)
